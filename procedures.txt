3.1.3.1 Procedure for inserting new driver

DELIMITER  $
CREATE PROCEDURE newDriver(IN dr_id CHAR(10), IN dr_name VARCHAR(20), IN dr_lname VARCHAR(20), IN salary FLOAT(7,2), IN licence ENUM('A','B','C','D'), IN route ENUM('LOCAL','ABROAD'), IN exp TINYINT(4))
BEGIN
	DECLARE drivers_id CHAR(10);
	DECLARE target_branch INT(11);

	SELECT d.drv_AT INTO drivers_id 
	FROM driver AS d 
	WHERE d.drv_AT=dr_id;

	IF (drivers_id is NULL) THEN
		SELECT subquery.wrk_br_code INTO target_branch
		FROM (SELECT w.wrk_br_code, COUNT(*) AS num_drivers FROM driver AS d INNER JOIN worker AS w ON d.drv_AT=w.wrk_AT GROUP BY w.wrk_br_code ORDER BY num_drivers ASC,w.wrk_br_code ASC LIMIT 1) AS subquery;
		IF (target_branch is NULL) THEN
		SELECT 'ERROR';
		ELSE
		INSERT INTO worker VALUES (dr_id,dr_name,dr_lname,salary,target_branch);
		INSERT INTO driver VALUES (dr_id,licence,route,exp);
		END IF;
	END IF;
END$
DELIMITER ;

3.1.3.2 Procedure for getting info for all trips of a branch

DELIMITER $
CREATE PROCEDURE get_trip_info(IN branch INT(11),IN from_date DATETIME,IN to_date DATETIME)
BEGIN
	DECLARE cost FLOAT(7,2);
	DECLARE capacity TINYINT(4);
	DECLARE reservations TINYINT(4);
	DECLARE driver_name VARCHAR(20);
	DECLARE driver_lname VARCHAR(20);
	DECLARE guide_name VARCHAR(20);
	DECLARE guide_lname VARCHAR(20);
	DECLARE departure DATETIME;
	DECLARE return_date DATETIME;

	DECLARE finishedFlag INT;
	DECLARE tripCursor CURSOR FOR
		SELECT t.tr_cost,t.tr_maxseats,MAX(r.res_seatnum),w.wrk_name,w.wrk_lname,w2.wrk_name,w2.wrk_lname,t.tr_departure,t.tr_return 			FROM trip AS t
		INNER JOIN reservation AS r ON r.res_tr_id=t.tr_id
		INNER JOIN driver AS d ON d.drv_AT=t.tr_drv_AT
		INNER JOIN guide AS g ON g.gui_AT=t.tr_gui_AT
		INNER JOIN worker AS w ON w.wrk_AT=d.drv_AT
		INNER JOIN worker AS w2 ON w2.wrk_AT=g.gui_AT
		WHERE t.tr_br_code=branch AND (t.tr_departure>=from_date AND t.tr_departure<=to_date) GROUP BY r.res_tr_id;
	
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finishedFlag=1;

	OPEN tripCursor;
	SET finishedFlag=0;
	FETCH tripCursor INTO cost,capacity,reservations,driver_name,driver_lname,guide_name,guide_lname,departure,return_date;

	WHILE (finishedFlag=0) DO
		SELECT cost AS 'Trip Cost',capacity AS '#Seats',reservations AS '#Researved Seats',(capacity-reservations) AS '#Empty Seats',driver_name AS 'Driver Name',driver_lname AS 'Driver Last Name',guide_name AS 'Guide Name',guide_lname AS 'Guide Last Name',departure AS 'Departure Date',return_date AS 'Return Date';
		
		FETCH tripCursor INTO cost,capacity,reservations,driver_name,driver_lname,guide_name,guide_lname,departure,return_date;
	END WHILE;
	CLOSE tripCursor;
END$

3.1.3.3 Procedure for removing an admin worker if he is not a manager

DELIMITER $
CREATE PROCEDURE del_admin(IN name VARCHAR(20),IN lname VARCHAR(20))
BEGIN
	DECLARE admin_id CHAR(10);
	DECLARE admin_property ENUM('LOGISTICS','ADMINISTRATIVE','ACCOUNTING');

	SELECT w.wrk_AT,a.adm_type INTO admin_id,admin_property 
	FROM worker AS w 
	INNER JOIN admin AS a ON a.adm_AT=w.wrk_AT 
	WHERE w.wrk_name=name and w.wrk_lname=lname;

	IF (admin_id IS NOT NULL) THEN
		IF (admin_property='ADMINISTRATIVE') THEN
			SELECT 'Selected person is branch manager. Deletion of a branch manager is not permitted';
		ELSE
			DELETE FROM worker WHERE wrk_AT=admin_id;
		END IF;
	END IF;
END$
DELIMITER ;

3.1.3.4
α)
/* Without indexing:
call get_Res_Offers_Names(50,100);
Query OK, 0 rows affected (34.730 sec)
 */

DELIMITER $
CREATE PROCEDURE get_Res_Offers_Names(IN from_amount FLOAT,IN to_amount FLOAT)
BEGIN
	SELECT cust_name AS 'Customer Name',cust_lname AS 'Customer Last Name'
	FROM reservation_offers
	WHERE advance_fee>=from_amount AND advance_fee<=to_amount
END $

DELIMITER ;

DELIMITER $
CREATE PROCEDURE get_Res_Offers_Names(IN from_amount FLOAT(7,2),IN to_amount FLOAT(7,2))
BEGIN
DECLARE first_name VARCHAR(20);
DECLARE last_name VARCHAR(20);
DECLARE finishedFlag INT;

DECLARE namesCursor CURSOR FOR
	SELECT cust_name,cust_lname FROM reservation_offers WHERE advance_fee>=from_amount AND advance_fee<=to_amount;

DECLARE CONTINUE HANDLER FOR NOT FOUND SET finishedFlag=1;

OPEN namesCursor;
SET finishedFlag=0;
FETCH namesCursor INTO first_name,last_name;

WHILE(finishedFlag=0) DO
	SELECT first_name AS 'First Name',last_name AS 'Last Name';
	FETCH namesCursor INTO first_name,last_name;
END WHILE;
CLOSE namesCursor;
END$
DELIMITER ;

β)
/* Without indexing: Query OK, 1 row affected (0.062 sec) */


DELIMITER $

CREATE PROCEDURE get_Offers_Participation(IN input_last_name VARCHAR(20))
BEGIN
  DECLARE total_count INT;
  
  EXPLAIN
  SELECT COUNT(*) INTO total_count
  FROM reservation_offers
  WHERE cust_lname = input_last_name
  GROUP BY cust_lname;
  IF total_count IS NULL THEN
    EXPLAIN
    SELECT cust_name, cust_lname, trip_offer_code
    FROM reservation_offers
    WHERE cust_lname = input_last_name;
  ELSE
    EXPLAIN
    SELECT trip_offer_code, COUNT(*) AS total_people
    FROM reservation_offers
    WHERE cust_lname = input_last_name
    GROUP BY trip_offer_code;
  END IF;

END $

DELIMITER ;

DELIMITER $
CREATE PROCEDURE get_Offers_Participation(IN last_name VARCHAR(20))
BEGIN
DECLARE counter INT;
DECLARE name VARCHAR(20);
DECLARE lname VARCHAR(20);
DECLARE trip_code INT(10);
DECLARE no_participants INT;
DECLARE finishedFlag INT;

DECLARE personCursor CURSOR FOR
	SELECT count(*),trip_offer_code FROM reservation_offers WHERE cust_lname=last_name GROUP BY trip_offer_code;

DECLARE CONTINUE HANDLER FOR NOT FOUND SET finishedFlag=1;

SELECT COUNT(*) INTO counter 
FROM reservation_offers 
WHERE cust_lname=last_name GROUP BY cust_lname;

IF counter>1 THEN
	OPEN personCursor;
	SET finishedFlag=0;
	FETCH personCursor INTO no_participants,trip_code;
	
	WHILE (finishedFlag=0) DO
		SELECT no_participants AS '#Customers with that last name',trip_code AS 'Trip Offer Code';
		FETCH personCursor INTO no_participants,trip_code;
	END WHILE;
	CLOSE personCursor;
ELSE
	SELECT cust_name,cust_lname,trip_offer_code 
	INTO name,lname,trip_code
	FROM reservation_offers
	WHERE cust_lname=last_name;
	
	SELECT name AS 'Customer Name',lname AS 'Customer Last Name',trip_code AS 'Trip Offer Code';
END IF;
END$
DELIMITER ;


/* Testing code */
3.1.3.1
CALL newDriver('AT073','Nikos','Kapolas',5000.50,'A','ABROAD',14);

SELECT w.wrk_br_code,count(*) AS num_drivers FROM driver AS d
INNER JOIN worker AS w ON d.drv_AT=w.wrk_AT GROUP BY w.wrk_br_code ORDER BY num_drivers ASC;

SELECT w.wrk_br_code,count(*) 
FROM driver AS d INNER JOIN worker AS w ON d.drv_AT=w.wrk_AT GROUP BY w.wrk_br_code ORDER BY  ASC LIMIT 1;

drop procedure newDriver;
delete from worker where wrk_AT='AT072';

3.1.3.2
CALL get_trip_info(1111,'2023-01-01','2024-01-01');
DROP PROCEDURE get_trip_info;

3.1.3.3
SELECT w.wrk_AT,w.wrk_name,w.wrk_lname,a.adm_type FROM worker AS w
INNER JOIN admin AS a ON a.adm_AT=w.wrk_AT;

DELIMITER $

CREATE PROCEDURE example(IN first FLOAT,IN sec FLOAT)
BEGIN
SELECT cust_name,cust_lname FROM reservation_offers
WHERE advance_fee BETWEEN first AND sec;
END$
DELIMITER ;


/* Important */
EXPLAIN call get_Res_offers_names(50,70);

show index from reservation_offers;

alter table reservation_offers drop index idx_advance_fee;