3.1.4.1
/* Μετά από κάθε trigger θα καλούμε μια procedure η οποία θα αλλάζει το it_at της τελευταίας καταγραφής του πίνακα it_logs στο it_AT που χρησιμοποιεί αυτή τη στιγμή το GUI */
DELIMITER $

CREATE TRIGGER trip_insert_log
BEFORE INSERT ON trip
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'INSERT','trip',NOW());
END$

CREATE TRIGGER trip_update_log
BEFORE UPDATE ON trip
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'UPDATE','trip',NOW());
END$

CREATE TRIGGER trip_delete_log
BEFORE DELETE ON trip
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'DELETE','trip',NOW());
END$

CREATE TRIGGER reservation_insert_log
BEFORE INSERT ON reservation
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'INSERT','reservation',NOW());
END$

CREATE TRIGGER reservation_update_log
BEFORE UPDATE ON reservation
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'UPDATE','reservation',NOW());
END$

CREATE TRIGGER reservation_delete_log
BEFORE DELETE ON reservation
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'DELETE','reservation',NOW());
END$

CREATE TRIGGER event_insert_log
BEFORE INSERT ON event
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'INSERT','event',NOW());
END$

CREATE TRIGGER event_update_log
BEFORE UPDATE ON event
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'UPDATE','event',NOW());
END$

CREATE TRIGGER event_delete_log
BEFORE DELETE ON event
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'DELETE','event',NOW());
END$

CREATE TRIGGER travel_to_insert_log
BEFORE INSERT ON travel_to
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'INSERT','travel_to',NOW());
END$

CREATE TRIGGER travel_to_update_log
BEFORE UPDATE ON travel_to
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'UPDATE','travel_to',NOW());
END$

CREATE TRIGGER travel_to_delete_log
BEFORE DELETE ON travel_to
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'DELETE','travel_to',NOW());
END$

CREATE TRIGGER destination_insert_log
BEFORE INSERT ON destination
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'INSERT','destination',NOW());
END$

CREATE TRIGGER destination_update_log
BEFORE UPDATE ON destination
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'UPDATE','destination',NOW());
END$

CREATE TRIGGER destination_delete_log
BEFORE DELETE ON destination
FOR EACH ROW
BEGIN 
	INSERT INTO it_logs(IT_id,action,table_name,log_date) VALUES
	(USER(),'DELETE','destination',NOW());
END$

DELIMITER ;


3.1.4.2
DELIMITER $

CREATE TRIGGER prevent_trip_update
BEFORE UPDATE ON trip
FOR EACH ROW
BEGIN
    DECLARE res_count INT;

    IF NEW.tr_departure <> OLD.tr_departure OR
       NEW.tr_return <> OLD.tr_return OR
       NEW.tr_cost <> OLD.tr_cost THEN

        SELECT COUNT(*) INTO res_count
        FROM reservation
        WHERE res_tr_id = OLD.tr_id;

        IF res_count > 0 THEN
            SIGNAL SQLSTATE '45000'
                SET MESSAGE_TEXT = 'Can not update trip. Reservations already exist.';
        END IF;

    END IF;
END $


3.1.4.2
DELIMITER $

CREATE TRIGGER prevent_salary_reduction
BEFORE UPDATE ON worker
FOR EACH ROW
BEGIN
	DECLARE salary FLOAT(7,2);
	DECLARE finishedFlag INT;

	DECLARE salaryCursor CURSOR FOR
		SELECT wrk_salary FROM worker WHERE wrk_salary=OLD.wrk_salary;
	
	DECLARE CONTINUE HANDLER FOR NOT FOUND SET finishedFlag=1;
	
	OPEN salaryCursor;
	SET finishedFlag=0;

	FETCH salaryCursor INTO salary;
	WHILE (finishedFlag=0) DO
		IF (NEW.wrk_salary<salary) THEN
			SIGNAL SQLSTATE '45000'
				SET MESSAGE_TEXT='Can not reduce worker salary.';
		END IF;
		FETCH salaryCursor INTO salary;
	END WHILE;
	CLOSE salaryCursor;
END$

DELIMITER ;


// trigger that checks if a worker has reached max number of misconducts(5) and adds them to 
// blacklist

DELIMITER $

CREATE TRIGGER blacklist_worker
AFTER INSERT ON misconducts
FOR EACH ROW
BEGIN
	DECLARE misconducts_counter INT;
	DECLARE name VARCHAR(10);
	DECLARE last_name VARCHAR(10);

	SELECT COUNT(*),msc_wrk_name,msc_wrk_lname INTO misconducts_counter,name,last_name FROM misconducts 
	WHERE msc_wrk_AT=NEW.msc_wrk_AT;

	IF misconducts_counter >=5 THEN
		INSERT INTO blacklist VALUES
		(NEW.msc_wrk_AT,name,last_name,'5 WORK MISCONDUCTS');
	END IF;
END$

DELIMITER ;

// Two new triggers that check before each insert and update in worker table if the new worker is blacklisted. If true, the update/insert action is prohibited
DELIMITER $

CREATE TRIGGER check_new_worker_insert
BEFORE INSERT ON worker
FOR EACH ROW
BEGIN
	DECLARE isBlacklisted INT;

	SELECT COUNT(*) INTO isBlacklisted FROM blacklist WHERE blk_wrk_AT=NEW.wrk_AT;

	IF isBlacklisted>0 THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Unable to insert worker. Worker is blacklisted.';
	END IF;
END $

CREATE TRIGGER check_report_insert
BEFORE INSERT ON misconducts
FOR EACH ROW
BEGIN
	DECLARE blacklisted INT;

	SELECT COUNT(*) INTO blacklisted FROM blacklist WHERE blk_wrk_AT=NEW.msc_wrk_AT;

	IF blacklisted>0 THEN
		SIGNAL SQLSTATE '45000'
		SET MESSAGE_TEXT = 'Unable to file report. Worker is blacklisted.';
	END IF;
END $

DELIMITER ;

